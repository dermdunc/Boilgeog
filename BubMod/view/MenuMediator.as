package BubMod.view {		import org.puremvc.as3.interfaces.*;    import org.puremvc.as3.patterns.mediator.Mediator;	import BubMod.model.*;	import BubMod.utilities.*;	import BubMod.view.*;	import BubMod.view.components.*;	import fl.transitions.Tween;	import fl.transitions.easing.Back;	import flash.events.*;	import flash.utils.*;		public class MenuMediator extends Mediator implements IMediator {				// Constants:		public static const NAME:String = "MenuMediator";		private var menuWidth:int = 0;		private var menuDataProxy:MenuDataProxy;		private var schemaDataProxy:SchemaDataProxy;		private var _tempEntity:EntityMC;				// Constructor		public function MenuMediator( menu:menuMask ) {        	super( NAME, menu);						//Hold the menus width			menuWidth = menu.width;						// Retrieve reference to frequently consulted Proxies			menuDataProxy = facade.retrieveProxy( MenuDataProxy.NAME ) as MenuDataProxy;			schemaDataProxy = facade.retrieveProxy( SchemaDataProxy.NAME ) as SchemaDataProxy;						//Create a new entity in memory			addNewEntity()						//Setup the menu			//Set labels on and state of components			menu.mainMenu.pkChkBox.label = "PK";			menu.mainMenu.fkChkBox.label = "FK";			menu.mainMenu.addAttributeBtn.label = "New Attribute";			menu.mainMenu.addEntityBtn.label = "New Entity";			menu.mainMenu.relatedTableCB.enabled = false;			menu.mainMenu.relatedKeyCB.enabled = false;			menu.mainMenu.saveSchemaBtn.label = "Save Schema";			menu.mainMenu.newSchemaBtn.label = "New Schema";			//Add relevant event listeners to the components			menu.mainMenu.relatedTableCB.addEventListener(Event.CHANGE, onRelatedTableSelectionChanged);			menu.mainMenu.addEntityBtn.addEventListener(MouseEvent.CLICK, onAddEntityBtnClick);			menu.mainMenu.addAttributeBtn.addEventListener(MouseEvent.CLICK, onAddAttributeBtnClick);			menu.mainMenu.fkChkBox.addEventListener(Event.CHANGE, onFkChkBoxChanged);			menu.mainMenu.saveSchemaBtn.addEventListener(MouseEvent.CLICK, onSaveSchemaBtnClick);			menu.mainMenu.newSchemaBtn.addEventListener(MouseEvent.CLICK, onNewSchemaBtnClick);			menu.mainMenu.attributeLists.addEventListener(MouseEvent.DOUBLE_CLICK, deleteAttribute);			menu.mainMenu.attributeLists.addEventListener(MouseEvent.CLICK, loadAttributeInfo);			menu.mainMenu.entitiesLists.addEventListener(MouseEvent.DOUBLE_CLICK, deleteEntity);			menu.mainMenu.entitiesLists.addEventListener(MouseEvent.CLICK, loadEntityInfo);			menu.mainMenu.hideMenu.addEventListener(MouseEvent.CLICK, onHideBtnClicked);			menu.addEventListener(MouseEvent.MOUSE_OVER, turnOffNavigation);			menu.addEventListener(MouseEvent.MOUSE_OUT, turnOnNavigation);			menu.mainMenu.schemaLists.addEventListener(MouseEvent.DOUBLE_CLICK, deleteSchema);			menu.mainMenu.schemaLists.addEventListener(MouseEvent.CLICK, loadSchemaInfo);			//Populate some required fields			loadSchemas();			populateTablesCB();		}				//Function which tells the main stage to turn off navigation		private function turnOffNavigation(event:MouseEvent):void {			sendNotification(ApplicationFacade.STOP_NAVIGATION, "stop");		}				//Function which tells the main stage to turn on navigation		private function turnOnNavigation(event:MouseEvent):void {			sendNotification(ApplicationFacade.START_NAVIGATION, "start");		}				//Function which creates a new entity in memory that is used by the menu		private function addNewEntity():void {			var spaceObject:SpaceObject = PointsHelper.createRandomObject(2000,3000,5000);						_tempEntity = new EntityMC(spaceObject) as EntityMC;		}				//Function to populate the related tables combobox		private function populateTablesCB():void {			//Cleare the related table combo box			menu.mainMenu.relatedTableCB.removeAll();			//Retrieve the entities array from the schemaDataProxy			var entitiesArray:Array = schemaDataProxy.getEntitiesArray();						//Check that the entities array contains some entities			if (entitiesArray != null && entitiesArray.length > 0)			{				//Loop through each entity and add it to the related table combobox				for (var i:int = 0; i < entitiesArray.length; i++) {					var entityName = entitiesArray[i].getName();					menu.mainMenu.relatedTableCB.addItem({label:entityName,data:entityName});				}			}		}			//Returns the menu		private function get menu():menuMask		{			return viewComponent as menuMask;		}				//Retrieves and populates a selected entities info when that entity is clicked		private function loadEntityInfo(event:MouseEvent):void {			//Check that the selected item is valid			if (menu.mainMenu.entitiesLists.selectedItem != null)			{				//If it is, retrieve the the entity from the schemaDataProxy based on the entityId				var selectedEntity:EntityMC = schemaDataProxy.getEntityById(menu.mainMenu.entitiesLists.selectedItem.data);				if (selectedEntity != null)				{					//If this is a valid entity, then set the temp entity equal to this selected entity 					_tempEntity = selectedEntity;					//Load the entities attributes					loadAttributes(selectedEntity);				}			}		}				//Function which calls the retrieve schema command		private function loadSchemaInfo(event:MouseEvent):void {			//Check that the selected schema is valid			if (menu.mainMenu.schemaLists.selectedItem != null)			{				//Reset the schema name textbox				menu.mainMenu.schemaName.text = menu.mainMenu.schemaLists.selectedItem.label;				//If it is, send the schemas id to the retrieveSchemaCommand to be retrieved from the database				sendNotification(ApplicationFacade.RETRIEVE_SCHEMA, menu.mainMenu.schemaLists.selectedItem.data)			}		}				//Function which loads all the users available schemas		private function loadSchemas():void {			//Clear the schema list			menu.mainMenu.schemaLists.removeAll();			//Pull the schema dictionary from the schema data proxy - this holds all the users schemas names and ids			var schemaDict:Dictionary = schemaDataProxy.getSchemaDictionary();			//Confirm the schema dictionary is valid			if (schemaDict != null)			{				//Loop through the dictionary and add each schema to the schema list				for (var key:Object in schemaDict) {					var schemaId:int = key as int;					var schemaName:String = schemaDict[key];					menu.mainMenu.schemaLists.addItem({label:schemaName, data:schemaId});				}			}			loadEntities();		}				private function loadEntities():void {			//Clear the entities list			menu.mainMenu.entitiesLists.removeAll();			//Retrieve the entities array from the schema data proxy			var entitiesArray:Array = schemaDataProxy.getEntitiesArray();						//Check that the entities array contains some entities			if (entitiesArray != null && entitiesArray.length > 0)			{				//Loop through the entities array and add each entity to the entities list				for (var i:int = 0; i < entitiesArray.length; i++) {					//Display the entity name					var entityName:String = entitiesArray[i].getName();					//Use the unique entity id as the value					var entityId:int = entitiesArray[i].getEntityId();					menu.mainMenu.entitiesLists.addItem({label:entityName, data:entityId});				}			}		}				//Function which loads all an entities attribtues		private function loadAttributes(selectedEntity:EntityMC):void {			//Clear the attribtues list			menu.mainMenu.attributeLists.removeAll();			//Get the attribute array from the selected entity			var attributesArray:Array = selectedEntity.getAttributes();			//Check that the attributes array contains some attributes			if (attributesArray != null && attributesArray.length > 0)			{				//Loop through the attributes array and add each entity to the attributes list				for (var i:int =0; i < attributesArray.length; i++) {					//Display the attribute name					var attributeName:String = attributesArray[i].getAttributeName();					//Use the unique attribute id as the value					var attributeId:int = attributesArray[i].getAttributeId();					menu.mainMenu.attributeLists.addItem({label:attributeName, data:attributeId});				}			}		}				//Load a specific attributes information		private function loadAttributeInfo(event:MouseEvent):void {			//Check that the selected attribute is valid			if (menu.mainMenu.attributeLists.selectedItem != null)			{				//Retrieve the attribute id from the attributes list				var attributeId:int = menu.mainMenu.attributeLists.selectedItem.data;				//Clear all the attribtue components apart from the attributes list				clearAttributes();				//Retrieve the selected attribute based on its id				var selectedAttribute:Attribute = _tempEntity.getAttributeById(menu.mainMenu.attributeLists.selectedItem.data);				//Confirm that the selected attribtue is valid				if (selectedAttribute != null)				{					//Setup the related attribute components					menu.mainMenu.attributeName.text = selectedAttribute.getAttributeName();					menu.mainMenu.pkChkBox.selected = Boolean(selectedAttribute.getPrimaryKey());					menu.mainMenu.fkChkBox.selected = Boolean(selectedAttribute.getForeignKey().getForeignKeyStatus());					if (Boolean(selectedAttribute.getForeignKey().getForeignKeyStatus()))					{						//If the attribute is a foreign key then set its related table and key						menu.mainMenu.relatedTableCB.enabled = true;						menu.mainMenu.relatedKeyCB.enabled = true;						populateTablesCB();						menu.mainMenu.relatedTableCB.text = selectedAttribute.getForeignKey().getRelatedTable();						populateForeignKeys(selectedAttribute.getForeignKey().getRelatedTable());						menu.mainMenu.relatedKeyCB.text = selectedAttribute.getForeignKey().getRelatedKey();					}					else					{						//Otherwise reset the related table and key components						menu.mainMenu.relatedTableCB.removeAll();						menu.mainMenu.relatedKeyCB.removeAll();						menu.mainMenu.relatedTableCB.enabled = false;						menu.mainMenu.relatedKeyCB.enabled = false;					}				}			}		}				//Function which deletes an attribute		private function deleteAttribute(event:MouseEvent):void {			//Retrieve the selected attribute based on its id			var selectedAttribute:Attribute = _tempEntity.getAttributeById(menu.mainMenu.attributeLists.selectedItem.data);			if (selectedAttribute != null)			{				//If it's a valid attribute then remove it from the attribute list				menu.mainMenu.attributeLists.removeItem(menu.mainMenu.attributeLists.selectedItem);				//Remove the attribute from the entity				_tempEntity.removeAttribute(selectedAttribute);				//Clear all the attribute controls except for the attribute list				clearAttributes();			}		}				//Function which deletes a selected entity		private function deleteEntity(event:MouseEvent):void {			//Retrieve the selected entity based on its id			var selectedEntity:EntityMC = schemaDataProxy.getEntityById(menu.mainMenu.entitiesLists.selectedItem.data);			if (selectedEntity != null)			{				//Remove the entity from the entity list				menu.mainMenu.entitiesLists.removeItem(menu.mainMenu.entitiesLists.selectedItem);				//Remove the entity from the entity array				schemaDataProxy.removeEntity(selectedEntity);				//Remove the entity from the stage				sendNotification(ApplicationFacade.STAGE_REMOVE_BUBBLE, selectedEntity.targetObject);				//Remove all its attribtues				menu.mainMenu.attributeLists.removeAll();				//Clear all the attribtue componetns				clearAttributes();				//Clear the entity name textbox				menu.mainMenu.entityName.text = "";				//Create a new entity				addNewEntity();			}		}				//Function which deletes a selected schema		private function deleteSchema(event:MouseEvent):void {			//Retrieve the schemaId from the schema list			var selectedSchemaiD:int = menu.mainMenu.schemaLists.selectedItem.data;			//If the id is valid, remove the schema from the schema lists			menu.mainMenu.schemaLists.removeItem(menu.mainMenu.schemaLists.selectedItem);			//Call the delete schema command which will delete the schema from the database			sendNotification(ApplicationFacade.DELETE_SCHEMA, selectedSchemaiD);			//Clear all the attributes			menu.mainMenu.attributeLists.removeAll();			clearAttributes();			//Clear all the entities			menu.mainMenu.entitiesLists.removeAll();			//Clear the entity name textbox			menu.mainMenu.entityName.text = "";			//Check if there are any entities on the stage			if (schemaDataProxy.getEntitiesArray() != null) {				if(schemaDataProxy.getEntitiesArray().length > 0) {					var entitiesArray:Array = schemaDataProxy.getEntitiesArray();					//Loop through each entity and send a notification to the stage to remove it					for(var i:int = 0; i<entitiesArray.length; i++) {						sendNotification(ApplicationFacade.STAGE_REMOVE_BUBBLE, entitiesArray[i]);					}				}			}			//If it's an existing schema then we want to delete it from the DB			if (selectedSchemaiD > 0)			{				sendNotification(ApplicationFacade.DELETE_SCHEMA, selectedSchemaiD);			}		}				//Function which clears all the attributes related components		private function clearAttributes():void {			menu.mainMenu.fkChkBox.selected = false;			menu.mainMenu.pkChkBox.selected = false;			menu.mainMenu.relatedTableCB.text = "";			menu.mainMenu.relatedKeyCB.text = "";			menu.mainMenu.attributeName.text = "";		}				//Function which creates a new schema		private function onNewSchemaBtnClick(event:MouseEvent):void {			var schemaName:String = menu.mainMenu.schemaName.text;			if(schemaName != null && schemaName.length > 0)			{				//Check if there are any entities on the stage				if (schemaDataProxy.getEntitiesArray() != null) {					if(schemaDataProxy.getEntitiesArray().length > 0) {						var entitiesArray:Array = schemaDataProxy.getEntitiesArray();						//Loop through each entity and send a notification to the stage to remove it						for(var i:int = 0; i<entitiesArray.length; i++) {							sendNotification(ApplicationFacade.STAGE_REMOVE_BUBBLE, entitiesArray[i]);						}					}				}				//Reset the entities array stored in memory				schemaDataProxy.setEntitiesArray(new Array());				//Add the new schema to the schema dictionary				schemaDataProxy.addSchemaToDictionary(0, schemaName);				//Set the current schema name and id				schemaDataProxy.setSchemaName(schemaName);				schemaDataProxy.setSchemaId(0);				//Add the schema to the schema list box				menu.mainMenu.schemaLists.addItem({label:schemaName, data:0});				//Create a new temp entity				addNewEntity();			}			//If there is now schema name specified we can't save the schema			else			{				sendNotification(ApplicationFacade.SHOW_ALERT, "Please specify a schema name before saving");			}		}					//Function to add a new entity		private function onAddEntityBtnClick(event:MouseEvent):void {			//Retrieve the entity name from the menu			var entityName:String = menu.mainMenu.entityName.text;			//Make sure the name is valid			if(entityName != null && entityName.length > 0)			{				//Update the temp entity with the selected entities details				_tempEntity.setName(entityName);				//Create a new sphere/target object				var studentEntityInstance:Sphere = new Sphere(_tempEntity.getName(), _tempEntity.getAttributes());				studentEntityInstance.name = "studentEntity" + (schemaDataProxy.getEntityCount() + 1);			    _tempEntity.targetObject = studentEntityInstance;								//Add the new entity to the entities list and call the create entity command				menu.mainMenu.entitiesLists.addItem({label:entityName, data:_tempEntity.getNextAttributeId()});				sendNotification(ApplicationFacade.CREATE_ENTITY, _tempEntity);								//Clear the menus entities and attributes sections				clearAttributes();				menu.mainMenu.entityName.text = "";				//Create a new temp entity				addNewEntity();			}			//If the name isn't valid, send the user a message			else			{				sendNotification(ApplicationFacade.SHOW_ALERT, "Please specify an entity name before saving");			}		}				//Function which adds a new attribute to an entity		private function onAddAttributeBtnClick(event:MouseEvent):void {			//Get the new attribute name and check if it's valid			var attributeName:String = menu.mainMenu.attributeName.text;			if(attributeName != null && attributeName.length > 0)			{				//Create a new attribute and set its details from what the user has entered in the menu				var attribute:Attribute = new Attribute(_tempEntity.getNextAttributeId());				attribute.setAttributeName(menu.mainMenu.attributeName.text);				attribute.setPrimaryKey(menu.mainMenu.pkChkBox.selected);				if (menu.mainMenu.fkChkBox.selected) {					var foreignKey:ForeignKey = new ForeignKey();					foreignKey.setForeignKeyStatus(true);					foreignKey.setRelatedTable(menu.mainMenu.relatedTableCB.text);					foreignKey.setRelatedKey(menu.mainMenu.relatedKeyCB.text);					//If it's a foreign key we want to set the relationship line at this point too					foreignKey.setConnectionName(menu.mainMenu.attributeName.text + "connection");					attribute.setForeignKey(foreignKey)				}								//Add the attribute to the temp entity				_tempEntity.addAttribute(attribute);				//Add the attribute to the attributes list				menu.mainMenu.attributeLists.addItem( {label:menu.mainMenu.attributeName.text, data:attribute.getAttributeId()} );				//Clear all the related attribute components				clearAttributes();			}			//If it's not valid, let the user know			else			{				sendNotification(ApplicationFacade.SHOW_ALERT, "Please specify an attribute name before saving");			}		}				//Function which saves a schema		private function onSaveSchemaBtnClick(event:MouseEvent):void {			//Get the schema name and check that it's valid			var schemaName:String = menu.mainMenu.schemaName.text;			if(schemaName != null && schemaName.length > 0)			{				//Send the schema id to the save schema command to be sent to the server side scripts				sendNotification(ApplicationFacade.SAVE_SCHEMA, menu.existingSchemaCB.selectedItem.data);			}			//If it's not valid, then let the user know			else			{				sendNotification(ApplicationFacade.SHOW_ALERT, "Please specify an entity name before saving");			}		}				//Function which retrieves a specific schema		private function onLoadSchemaBtnClick(event:MouseEvent):void {			schemaDataProxy.setSchemaName(menu.existingSchemaCB.selectedItem.label.toString());			schemaDataProxy.setSchemaId(menu.existingSchemaCB.selectedItem.data.toString());			sendNotification(ApplicationFacade.RETRIEVE_SCHEMA, menu.existingSchemaCB.selectedItem.data.toString());		}				//Event called when the user checks or unchecks the foreign key checkbox		private function onFkChkBoxChanged(event:Event): void {			//Enable or disable both related table and key combo boxes based on if the checkbox is checked or not			menu.mainMenu.relatedTableCB.enabled = menu.mainMenu.fkChkBox.selected;			menu.mainMenu.relatedKeyCB.enabled = menu.mainMenu.fkChkBox.selected;						//If the foreign key checkbox is checked, then populate the related tables combobox			if (Boolean(menu.mainMenu.fkChkBox.selected))			{				populateTablesCB();			}			//Otherwise clear both combo boxes			else			{				menu.mainMenu.relatedTableCB.removeAll();				menu.mainMenu.relatedKeyCB.removeAll();			}		}				//Function fired when the user selects a related table		private function onRelatedTableSelectionChanged(event:Event):void{			//Populate the related keys combobox with the required attributes			populateForeignKeys(menu.mainMenu.relatedTableCB.selectedItem.data.toString());		}				//Function which populates all the foreign keys		private function populateForeignKeys(tableName:String):void {			//Clear the foreign key checkbox			menu.mainMenu.relatedKeyCB.removeAll();			//Get the entities array from the schema data proxy			var entitiesArray:Array = schemaDataProxy.getEntitiesArray();						//Loop through each entity and check if it matches the selected entity			for (var i:int = 0; i < entitiesArray.length; i++) {				var entityName:String = entitiesArray[i].getName();				if (entityName == tableName) {					//If it does then retrieve its attributes array					var attributesArray:Array = entitiesArray[i].getAttributes();					//Loop through each attribute and add it to the related key combo box					for (var j:int = 0; j < attributesArray.length; j++) {						var attributeName:String = attributesArray[j].getAttributeName();						menu.mainMenu.relatedKeyCB.addItem({label:attributeName,data:attributeName});					}				}			}		}				//Function to hide the menu		private function onHideBtnClicked(event:MouseEvent) {			//sends a notification to the stage to show the show menu button			sendNotification(ApplicationFacade.SHOW_MENU_BTN, null);			showHidePanel();		}				//Function which shows or hides the menu		private function showHidePanel():void {			var xlocation:int = menuDataProxy.getMenuX();			var twSlide:Tween;			/*if (menu.x > 900) {				//menu.rotation = 180;				twSlide = new Tween(menu, "x", Back.easeOut, xlocation, xlocation - 220, 10);			}			else {				//menu.rotation = 0;				twSlide = new Tween(menu, "x", Back.easeIn, xlocation + 220, xlocation, 10);			}*/			if (menu.width > 0) {				menuWidth = menu.width;				menu.width = 0;				twSlide = new Tween(menu, "x", Back.easeOut, xlocation, xlocation - 220, 10);			}			else {				menu.width = menuWidth;				twSlide = new Tween(menu, "x", Back.easeIn, xlocation + 220, xlocation, 10);			}		}				// Return list of Nofitication names that Mediator is interested in		override public function listNotificationInterests():Array {		    			return  [					ApplicationFacade.SHOW_HIDE_MENU,					ApplicationFacade.LOAD_TABLES			        ];		}				// Handle all notifications this Mediator is interested in		override public function handleNotification(note:INotification):void  		{			switch (note.getName()) {				case ApplicationFacade.SHOW_HIDE_MENU:					showHidePanel();					break;				case ApplicationFacade.LOAD_TABLES:					loadEntities();					break;			}		}			// Public Methods:		// Protected Methods:	}	}