package BubMod.view {    import org.puremvc.as3.interfaces.*;    import org.puremvc.as3.patterns.mediator.Mediator;	import BubMod.model.*;	import BubMod.utilities.*;	import BubMod.view.components.*;	import flash.display.*;	import flash.events.*;	import flash.geom.*;	import fl.controls.*;	import flash.text.*;    // Mediator for interacting with the Stage.    public class StageMediator extends Mediator implements IMediator     {		private var tracer:MovieClip;     	// Cannonical name of the Mediator        public static const NAME:String = 'StageMediator';		public var schemaCamera:SchemaCamera;		private var entityDataProxy:EntityDataProxy;		private var schemaDataProxy:SchemaDataProxy;		private var menuDataProxy:MenuDataProxy;		//Some variables used to calculate the mouse movement		private var xmouseMemory:Number;		private var ymouseMemory:Number;		private var txMemory:Number;		private var tyMemory:Number;		private var tzMemory:Number;		//Boolean used to turn the navigation on and off		private var navigate:Boolean;		//Some constants used in the navigation		public var movementFactor:Number = 100;		public var rotationFactor:Number = 2;		public var inertia:Number = 5;		private var drag:Boolean = false;		private var canvas_mc:MovieClip;				public var totalItems:Number = 25;		        // Constructor         public function StageMediator(viewComponent:Object) {                        // pass the viewComponent to the superclass            super( NAME, viewComponent );            			//Add event listeners to handle the users navigation			viewComponent.addEventListener(MouseEvent.MOUSE_DOWN, OnMouseDown);			viewComponent.addEventListener(MouseEvent.MOUSE_UP, OnMouseUp);			viewComponent.addEventListener(MouseEvent.MOUSE_MOVE, rotate);			viewComponent.addEventListener(KeyboardEvent.KEY_DOWN, OnkeyDown);						//Create an onEnterFrame event handler which will constantly update the entities on the stage			viewComponent.addEventListener(Event.ENTER_FRAME, OnEnter);			navigate = true;			//viewComponent.btnSlidePanel.addEventListener(MouseEvent.MOUSE_DOWN, showHidePanel);						// Retrieve reference to frequently consulted Proxies			schemaDataProxy = facade.retrieveProxy( SchemaDataProxy.NAME ) as SchemaDataProxy;			entityDataProxy = facade.retrieveProxy( EntityDataProxy.NAME ) as EntityDataProxy;			menuDataProxy = facade.retrieveProxy( MenuDataProxy.NAME ) as MenuDataProxy;						//Create a new schema camera and set it equal to the centre point of the stage			schemaCamera = new SchemaCamera(stage.stageWidth/2,stage.stageHeight/2,-2500,0,0,0,400);						//Set the camera on the entityDataProxy equal to the new schema camera			entityDataProxy.setCamera(schemaCamera);						canvas_mc = new MovieClip();        }        		//Function taken from 		private function sortZ (dParent:DisplayObjectContainer):void {			for (var i:int = dParent.numChildren - 1; i > 0; i--) {				var bFlipped:Boolean = false;								for (var o:int = 0; o < i; o++) {					if (dParent.getChildAt(o).y > dParent.getChildAt(o+1).y) {						dParent.swapChildrenAt(o,o+1);						bFlipped = true;					}				}				if (!bFlipped)					return;			}		}		private function OnEnter(e:Event):void {			//Check if the user is on a navigable region of the stage			if (navigate)			{				//Retrieve the current entities array from the schemaDataProxy				var entitiesArray:Array = schemaDataProxy.getEntitiesArray();								var i:int;									//Add bubbles to the scene							if (entitiesArray != null)				{					//Retrieve the entity camera from the entitDataProxy					var entityCamera:EntityCamera = entityDataProxy.getCamera();					if (entityCamera == null)					{						//If it hasn't been set yet, then initialize a new one						entityCamera = new EntityCamera(stage.stageWidth/2,stage.stageHeight/2,0,0,0,0,500);					}										//Loop through each entity and send its mediator a message telling it to update its position					for (i=0; i < entitiesArray.length; i++){						sendNotification(ApplicationFacade.UPDATE, entityCamera, i.toString());						var currentEntity:EntityMC = entitiesArray[i] as EntityMC						var currentBubble:Sphere = currentEntity.targetObject as Sphere;						sendNotification(ApplicationFacade.RENDER, entityCamera, i.toString());					}					//Call the simple Z Sorter class from utilities to sort the depths on the stage					SimpleZSorter.sortClips(stage);				}			}		}				private function SortZs(): void {			//SimpleZSorter.sortClips(stage);		}				private function showHidePanel(event:MouseEvent):void {			//var twSlide:Tween;			if (viewComponent.mcPanel.rotation == 180) {				viewComponent.mcPanel.rotation = 0;				//twSlide = new Tween(mcPanel, "x", Back.easeOut, ptPanelHome.x, ptPanelHome.x - 102, 10);			}			else {				viewComponent.btnSlidePanel.rotation = 180;				//twSlide = new Tween(mcPanel, "x", Back.easeIn, ptPanelHome.x - 102, ptPanelHome.x, 10);			}		}				//Fired when the user clicks on the stage		private function OnMouseDown(event:MouseEvent):void{			//Get the mouses position on stage			xmouseMemory = stage.mouseX;			ymouseMemory = stage.mouseY;			//Save the cameras current position			txMemory = schemaCamera.tx;			tyMemory = schemaCamera.ty;			drag = true;		}				//Funciton which tells the mediator the user has stopped navigating		private function OnMouseUp(event:MouseEvent):void{			drag = false;		}				//Function used to rotate the entities around 3D space		public function rotate(event:MouseEvent):void{			//Check if the user is in a navigable region on stage			if (navigate)			{				//Check if the user is currently navigating				if (drag)				{						//Get the mouse's stage postiont					var xMouse:Number = stage.mouseX;					var yMouse:Number = stage.mouseY;					//Calculate the cameras new depth					schemaCamera.txTarget = (ymouseMemory - yMouse)/rotationFactor + txMemory;					schemaCamera.tyTarget = (xmouseMemory - xMouse)/rotationFactor + tyMemory;					//Calculate the cameras rotation					schemaCamera.tx = (ymouseMemory - yMouse)/rotationFactor + txMemory;					schemaCamera.ty = (xmouseMemory - xMouse)/rotationFactor + tyMemory;				}			}		}				//Fired when user presses the up arrow		public function forward():void{			//Calculates the cameras position to give a zooming in effect			var radians:Number = (270-schemaCamera.ty) * Math.PI/180;			var xDelta = Math.cos(radians)*movementFactor;			var zDelta = Math.sin(radians)*movementFactor*-1;						schemaCamera.xTarget += xDelta ;			schemaCamera.zTarget += zDelta ;		}			//Fired when user presses the down arrow		public function backward():void{			//Calculates the cameras position to give a zooming out effect			var radians:Number = (270-schemaCamera.ty) * Math.PI/180;			var xDelta = Math.cos(radians)*-movementFactor;			var zDelta = Math.sin(radians)*-movementFactor*-1;						schemaCamera.xTarget += xDelta ;			schemaCamera.zTarget += zDelta ;		}			//Fired when the user presses the left arrow		public function left():void{			//Calculates the cameras position to give a panning left effect			var radians:Number = (270-schemaCamera.ty-90) * Math.PI/180;			var xDelta = Math.cos(radians)*movementFactor;			var zDelta = Math.sin(radians)*movementFactor*-1;						schemaCamera.xTarget += xDelta ;			schemaCamera.zTarget += zDelta ;		}			//Fired when the user presses the right arrow		public function right():void{			//Calcualtes the cameras position to give a panning right effect			var radians:Number = (270-schemaCamera.ty+90) * Math.PI/180;			var xDelta = Math.cos(radians)*movementFactor;			var zDelta = Math.sin(radians)*movementFactor*-1;						schemaCamera.xTarget += xDelta ;			schemaCamera.zTarget += zDelta ;		}			//Listens for keyboard interaction from the user		public function OnkeyDown(event:KeyboardEvent){			if(event.keyCode == 38 || event.keyCode == 87){				forward();			}			if(event.keyCode == 40 || event.keyCode == 83){				backward();			}			if(event.keyCode == 37 || event.keyCode == 65){				left();			}			if(event.keyCode == 39 || event.keyCode == 68){				right();			}			// rotate camera			schemaCamera.tx = Math.round((schemaCamera.tx+(schemaCamera.txTarget-schemaCamera.tx)/inertia)*10)/10;			schemaCamera.ty = Math.round((schemaCamera.ty+(schemaCamera.tyTarget-schemaCamera.ty)/inertia)*10)/10;						// move camera			schemaCamera.x = Math.round((schemaCamera.x + (schemaCamera.xTarget-schemaCamera.x)/inertia)*10)/10;			schemaCamera.z = Math.round((schemaCamera.z + (schemaCamera.zTarget-schemaCamera.z)/inertia)*10)/10;		}				private static function polar(len:Number,angle:Number):Point{			var radians:Number = angle*(Math.PI/180);			var x:Number = len * Math.cos(radians);			var y:Number = len * Math.sin(radians);			return new Point(x,y);		}				private static function convertAngleTo360(value:Number):Number{			var number:Number = value;			for(var i:Number=0;number>=360;i++){				number -= 360;			}			for(var j:Number=0;number<0;j++){				number += 360;			}			return number;		}				//Function which builds the relationships between 2 entities		//Takes the selected entity as an input		private function BuildRelationships(entity:EntityMC) {			//Get all the attributes of the entity			var attributes:Array = entity.getAttributes();			//Loop through all the attributes of the entity, and check which ones, if any, are foreign keys 			for (var i:int = 0; i < attributes.length; i++)			{				//Check if the attribute is a foreign key				var foreignKey:ForeignKey = attributes[i].getForeignKey();				if (Boolean(foreignKey.getForeignKeyStatus()))				{					//Check if the relationship movieclip has already been added to the stage					if (!Boolean(stage.getChildByName(foreignKey.getConnectionName())))						//If it hasn't, then add it						stage.addChild(foreignKey.connectionLine);										//Get the related table specified in the attribute					var relatedTable:String = foreignKey.getRelatedTable();					//Retrieve the primary entity from the stage					var primaryEntity:Sphere = viewComponent.getChildByName(entity.targetObject.name) as Sphere;					//Get the connecting entity based on its name					var connectingEntityMC:EntityMC = schemaDataProxy.getEntityByName(relatedTable) as EntityMC;					//Make sure the connecting entity stil exists					if (connectingEntityMC != null)					{						//Retrieve the connecting entity on the stage						var connectingEntity:Sphere = viewComponent.getChildByName(connectingEntityMC.targetObject.name) as Sphere;						if (connectingEntity != null)						{							//Only show the relationship if both entities are visisble (if they're Z is less than zero than they're not shown on stage and we don't want to have a relationship going nowhere)							if ((connectingEntity.z > 0) && (primaryEntity.z > 0))							{								//Clear all the graphics on the relationship line								foreignKey.connectionLine.graphics.clear();								//Create a new line								foreignKey.connectionLine.graphics.lineStyle(2.5, 0x999999, 100);								//LineTo and MoveTo methods only take a 2D point as parameter. We need to get the 3D equivalent ot the entities location on stage.								//To do this we use the localToGlobal function which translates the point from it's location on the entity to the equivalent 3D point on the stage								foreignKey.connectionLine.graphics.moveTo(primaryEntity.localToGlobal(primaryEntity.centrePoint).x, primaryEntity.localToGlobal(primaryEntity.centrePoint).y);								foreignKey.connectionLine.graphics.lineTo(connectingEntity.localToGlobal(connectingEntity.centrePoint).x, connectingEntity.localToGlobal(connectingEntity.centrePoint).y);							}						}					}				}			}		}				//Function which removes the relationships between 2 entities		//Takes the selected entity as an input		private function RemoveRelationships(entity:EntityMC) {			//Get all the attributes of the entity			var attributes:Array = entity.getAttributes();			//Loop through all the attributes of the entity, and check which ones, if any, are foreign keys 			for (var i:int = 0; i < attributes.length; i++)			{				//Check if the attribute is a foreign key				var foreignKey:ForeignKey = attributes[i].getForeignKey();				if (Boolean(foreignKey.getForeignKeyStatus()))				{					//Get the related table specified in the attribute					var relatedTable:String = foreignKey.getRelatedTable();					//Retrieve the primary entity from the stage					var primaryEntity:Sphere = viewComponent.getChildByName(entity.targetObject.name) as Sphere;					//Get the connecting entity based on its name					var connectingEntityMC:EntityMC = schemaDataProxy.getEntityByName(relatedTable) as EntityMC;					//Make sure the connecting entity stil exists					if (connectingEntityMC != null)					{						//Retrieve the connecting entity on the stage						var connectingEntity:Sphere = viewComponent.getChildByName(connectingEntityMC.targetObject.name) as Sphere;						if (connectingEntity != null)						{							//Clear all the graphics on the relationship line							foreignKey.connectionLine.graphics.clear();						}					}				}			}		}		/////////////////////////////////////////////////////////////////////		//		// SchemaCreated		//		/////////////////////////////////////////////////////////////////////				private function onSchemaCreated(args:Object):void		{			//We have a valid schema so now we want to create all the bubbles			sendNotification(ApplicationFacade.CREATE_BUBBLES, args);			//Check if the menu already exists on the stage			var menu:menuMask = stage.getChildByName("menu") as menuMask;			if (menu == null)				//If it doesn't, then we want to create a new menu instance				sendNotification(ApplicationFacade.CREATE_MENU, null);			else				//Otherwise we just want to re-populate the existing menu				sendNotification(ApplicationFacade.LOAD_TABLES, null);		}				/////////////////////////////////////////////////////////////////////		//		// Show or Hide the menu		//		/////////////////////////////////////////////////////////////////////				private function onMenuBtnClicked(vent:MouseEvent):void		{			//Tell the menu to hide itself			sendNotification(ApplicationFacade.SHOW_HIDE_MENU, null);			//Get the menu button and hide it as well			var menuBtn:showMenuBtn = stage.getChildByName("showMenuBtn") as showMenuBtn;			if (menuBtn != null)			{				//stage.removeChild(menuBtn);				menuBtn.alpha = 0;				//menuBtn.enabled = false;			}		}				// Return list of Nofitication names that Mediator is interested in		override public function listNotificationInterests():Array {		    			return  [					ApplicationFacade.ONENTERFRAME,					ApplicationFacade.SCHEMA_CREATED,					ApplicationFacade.STAGE_ADD_BUBBLE,					ApplicationFacade.STAGE_ADD_MENU,					ApplicationFacade.ZSorter,					ApplicationFacade.SORT_DEPTHS,					ApplicationFacade.BUILD_RELATIONSHIPS,					ApplicationFacade.REMOVE_RELATIONSHIPS,					ApplicationFacade.STAGE_REMOVE_BUBBLE,					ApplicationFacade.ADD_TABLE,					ApplicationFacade.REMOVE_TABLE,					ApplicationFacade.START_NAVIGATION,					ApplicationFacade.STOP_NAVIGATION,					ApplicationFacade.SHOW_MENU_BTN,					ApplicationFacade.SHOW_ALERT			        ];		}				// Handle all notifications this Mediator is interested in		override public function handleNotification(note:INotification):void  		{			//Variable to hold the entity for the various events			var entity:EntityMC;			switch (note.getName()) {				//Schema has been created				case ApplicationFacade.SCHEMA_CREATED:					trace("Schema was created and event heard");					onSchemaCreated(note.getBody());					break;				//User has entered the application				case ApplicationFacade.ONENTERFRAME:					trace("Entered frame");					break;				//Add a new entity/bubble to the stage                case ApplicationFacade.STAGE_ADD_BUBBLE:					//Retrieve the entity from the notification					var bubble:EntityMC = note.getBody() as EntityMC;					//Pull the sphere sprite from the entity					var targetObject:Sphere = bubble.targetObject as Sphere;					//Pull the entity name sprite from the entity					var objectName:TextField = bubble.objectName as TextField;					//Set the positions of the bubble and the bubble name					targetObject.x = (stage.stageWidth)/2;					objectName.x = targetObject.x;					targetObject.y = (stage.stageHeight)/2;					objectName.y = (targetObject.y - targetObject.width);					//Add both to the stage					stage.addChild(targetObject);					stage.addChild(objectName);                    break;				//Remove a new bubble from the stage				case ApplicationFacade.STAGE_REMOVE_BUBBLE:					//Retrieve the entity from the notification					var bubbleToRemove:EntityMC = note.getBody() as EntityMC;					//Pull the sphere sprite from the entity					var targetObject:Sphere = bubbleToRemove.targetObject as Sphere;					//Pull the entity name sprite from the entity					var objectName:TextField = bubbleToRemove.objectName as TextField;					//Pull the 2D Table Sprite from the entity					var table:Table = bubbleToRemove.expandedTable as Table;											//Check of the sphere is on the stage					if (!Boolean(stage.getChildByName(targetObject.name)));						stage.removeChild(targetObject);					//Check if the entity name is on the stage					if (!Boolean(stage.getChildByName(objectName.name)));						stage.removeChild(objectName);					//Check if the 2D table has been initialized yet					if (table != null)					{						//Check if the 2D table is on the stage						if (!Boolean(stage.getChildByName(table.name)));							stage.removeChild(table);					}					break;				//Add a 2D table to the stage				case ApplicationFacade.ADD_TABLE:					//Retrieve the entity from the notification					var expandedEntity:EntityMC = note.getBody() as EntityMC;					//Make sure the notification contains a valid entity					if (expandedEntity != null)					{						//Retrieve the 2D representation of the bubble from the entity						var bubblesTable = expandedEntity.expandedTable as Table;						//Set its stage position						bubblesTable.x = expandedEntity.targetObject.x;						bubblesTable.y = expandedEntity.targetObject.y;						bubblesTable.z = expandedEntity.targetObject.z;						//Add it to the stage						if (bubblesTable != null)						{							stage.addChild(bubblesTable);						}					}					break;				//Remove a 2D table from the stage				case ApplicationFacade.REMOVE_TABLE:					//Retrieve the 2D representation of the bubble from the notification					var bubblesTableToRemove:Table = note.getBody() as Table;					//Make sure a valid table was sent in the notification					if (bubblesTableToRemove != null)					{						//Check that the table exists on stage before removing it						if (!Boolean(stage.getChildByName(bubblesTableToRemove.name)));							stage.removeChild(bubblesTableToRemove);					}					break;				//Sort the depths on the stage				case ApplicationFacade.ZSorter:					SortZs();					break;				case ApplicationFacade.SORT_DEPTHS:										break;				//Add the menu to the stage				case ApplicationFacade.STAGE_ADD_MENU:					//Retrieve the menu from the notification					var menu:menuMask = note.getBody() as menuMask					//Add some event listeners to the menu					menu.addEventListener(MouseEvent.MOUSE_DOWN, menuMouseDown);					menu.addEventListener(MouseEvent.MOUSE_UP, menuMouseUp);					//Create a new hide meny button					var menuBtn:showMenuBtn = new showMenuBtn();					menuBtn.name = "showMenuBtn";					if (menu != null)					{						//Set the menus position and add it to the stage 						menu.x = (stage.stageWidth/2);						menu.y = (stage.stageHeight/2);						stage.addChild(menu);												//Set the menu buttons position						menuBtn.x = (menuBtn.width/2);						menuBtn.y = (menuBtn.height/2);						//We don't want to show the menu to start with						menuBtn.alpha = 0;												//Add a mouse click event handler to the menu button						menuBtn.addEventListener(MouseEvent.CLICK, onMenuBtnClicked);						//Add the menu button to the stage						stage.addChild(menuBtn);						//Save the menus x position in the menuDataProxy						menuDataProxy.setMenuX(menu.x);					}					break;				//Build an entities relationships				case ApplicationFacade.BUILD_RELATIONSHIPS:					//Retrieve the entity from the notification					entity = note.getBody() as EntityMC;					//Pass the entity to the BuildRelationships function					BuildRelationships(entity);					break;				//Remove an entities relationships				case ApplicationFacade.REMOVE_RELATIONSHIPS:					//Retrieve the entity from the notification					entity = note.getBody() as EntityMC;					//Pass the entity to the RemoveRelationships function					RemoveRelationships(entity);					break;				//User is in a navigable region of the stage				case ApplicationFacade.START_NAVIGATION:					navigate = true;					break;				//User is not in a navigable region of the stage (that is user is over the menu)				case ApplicationFacade.STOP_NAVIGATION:					navigate = false;					break;				//Show the menu button				case ApplicationFacade.SHOW_MENU_BTN:					var menuBtn:showMenuBtn = stage.getChildByName("showMenuBtn") as showMenuBtn;					if (menuBtn != null)					{						//Set the menu buttons alpha to 100%						menuBtn.alpha = 1;					}					break;				//Show the user an alert				case ApplicationFacade.SHOW_ALERT:					//Retrieve the alert message from the notification					var msg:String = note.getBody() as String;					//Create a new custom alert box					var msgBox:MessageBox = new MessageBox(msg);					//Centre it on the stage					msgBox.x = (stage.stageWidth/2) - (msgBox.width/2);					msgBox.y = (stage.stageHeight/2) - (msgBox.height/2);					//Add an event listener to its ok button to close it on a click					msgBox.okBtn.addEventListener(MouseEvent.CLICK, removeAlertBox);					//Set its name and add it to the stage					//We need its name to remove it when the user clicks the ok button					msgBox.name = "msgBox";					stage.addChild(msgBox);					break;			}		}				//Removes the alert box from the stage which is used to display warnings to the user		private function removeAlertBox(e:MouseEvent) {			var msgBox:MessageBox = stage.getChildByName("msgBox") as MessageBox;			if (msgBox != null)			{				stage.removeChild(msgBox);			}		}				//Stops dragging the menu		private function menuMouseUp(e:MouseEvent) {			e.currentTarget.stopDrag();		}				//Drags the menu		private function menuMouseDown(e:MouseEvent) {			e.currentTarget.startDrag()		}				private function sortDisplayList():void		{			var entityArray:Array = schemaDataProxy.getEntitiesArray();			var len:uint = entityArray.length;						//for (var i:int = 0; i < len-1; i++)			//{				//for (var j:int = i+1; j < len; j++)				//{					//if (clip(stage.getChildAt(i)).getDepth() > clip(stage.getChildAt(j)).getDepth())						//stage.swapChildrenAt(entityArray[i].targetObject,entityArray[j].targetobject);				//}			//}		}		        // Get the Mediator name        override public function getMediatorName():String {            return NAME;        }				/**         * Cast the viewComponent to its actual type.         *          * <P>         * This is a useful idiom for mediators. The         * PureMVC Mediator class defines a viewComponent         * property of type Object. </P>         *          * <P>         * Here, we cast the generic viewComponent to          * its actual type in a protected mode. This          * retains encapsulation, while allowing the instance         * (and subclassed instance) access to a          * strongly typed reference with a meaningful         * name.</P>         *          * @return stage the viewComponent cast to flash.display.Stage         */        protected function get stage():Stage{            return viewComponent as Stage;        }    }}