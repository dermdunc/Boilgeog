package BubMod.view.components {		import flash.display.Sprite;	import flash.events.*;	import flash.geom.*;	import flash.filters.*;	import flash.text.*;		///////////////////////////////////////////////////	// Based on an example tutorial found at flashandmath.com	///////////////////////////////////////////////////	public class Sphere extends Sprite{				var rad:Number=125;		var thumbWidth:Number=25;		var thumbHeight:Number=25;		var thumbsArray:Array=[];		var holdersArray:Array=[];		var picsArray:Array=[];		var midsArray:Array=[];		var jLen:Vector.<Number>=new Vector.<Number>();		var thetaStep:Vector.<Number>=new Vector.<Number>();		var phiStep:Number=30;		var phiTilt:Vector.<Number>=new Vector.<Number>();		var autoOn:Boolean=true;		var manualOn:Boolean=false;		var spSphere:Sprite;		var sphereName:String;		var attributesList:Array;		public var prevX:Number;		public var prevY:Number;		public var centrePoint:Point = new Point(0,0);				public function Sphere(sphereName:String, attributesList:Array) {			this.sphereName = sphereName;			if (attributesList != null)				this.attributesList = attributesList;			spSphere = new Sprite();			this.addChild(spSphere);						spSphere.x=0;			spSphere.y=0;			spSphere.z=rad;			phiTilt=Vector.<Number>([-90,-60,-30,0,30,60,90]);			jLen=Vector.<Number>([1,6,10,12,10,6,1]);			thetaStep=Vector.<Number>([0,60,36,30,36,60,0]);						setUpPics();			buildSphere();			spSphere.rotationY=0;			spSphere.rotationX=0;			spSphere.rotationZ=0;			spSphere.filters=[new GlowFilter(0x666666,1.0,6.0,6.0,2)];			rotateSphere(0,0,0);		}		/*		The function setUpPics populates the arrays thumbsArray and picsArray. 		Note the organization of thumbnails by circles on which they reside:		thumbsArray[0] - the north pole, thumbsArray[1] thumbnails of the first circle		down from the north pole, etc. 'picsArray' is organized similarly.				You can, of course, subsitute your own images, use thumbnails of		dimensions different from ours. Changing the number of thumbnails and their organization		would, however, require rewritting the script a bit. 		*/				private function setUpPics():void {			var entityName:modelObject = new modelObject();			entityName.objectName.text = sphereName;						thumbsArray[0]=[new StudentEntity()];			picsArray[0]=["pic1.jpg"];			thumbsArray[1]=[new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity()];			picsArray[1]=["pic2.jpg","pic3.jpg","pic4.jpg","pic5.jpg","pic6.jpg","pic7.jpg"];			thumbsArray[2]=[new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(), new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity()];			picsArray[2]=["pic8.jpg","pic9.jpg","pic10.jpg","pic11.jpg","pic12.jpg","pic13.jpg","pic14.jpg","pic15.jpg","pic16.jpg","pic17.jpg"];			thumbsArray[3]=[new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity()];			picsArray[3]=["pic18.jpg","pic19.jpg","pic20.jpg","pic21.jpg","pic22.jpg","pic23.jpg","pic24.jpg","pic25.jpg","pic26.jpg","pic27.jpg","pic28.jpg","pic29.jpg"];			thumbsArray[4]=[new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(), new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity(),new StudentEntity()];			picsArray[4]=["pic30.jpg","pic31.jpg","pic32.jpg","pic33.jpg","pic34.jpg","pic35.jpg","pic36.jpg","pic37.jpg","pic38.jpg","pic39.jpg"];			thumbsArray[5]=[new StudentEntity(),new StudentEntity(),new StudentEntity(), new StudentEntity(),new StudentEntity(),new StudentEntity()];			picsArray[5]=["pic40.jpg","pic41.jpg","pic42.jpg","pic43.jpg","pic44.jpg","pic45.jpg"];			thumbsArray[6]=[new StudentEntity()];			picsArray[6]=["pic46.jpg"];		}				/*		In the next function we actually create a 3D sphere of thumbnails by positioning		them in 3D within spSphere. Note the center of the sphere is at (0,0,0) of 		spSphere. It might be worth recalling that with our interpretation of		phi and theta each point P=(x,y,z) on the sphere corresponding to given values		of phi and theta is given by:				x = rad * sin(phi) * sin(theta),				y = -rad * cos(phi),				z = -rad * sin(phi) * cos(theta).				Within the function, we populate 'holdersArray' and 'midsArray'. We assign thumbnails		to holdersArray elements, position holdersArray elements, tilt them, give them names.		We literally build our sphere.		*/				public function buildSphere():void {			var i:int;			var j:int;			var tStep:Number;						var pStep:Number=phiStep*Math.PI/180;			for(i=0;i<7;i++){				holdersArray[i]=[];				midsArray[i]=[];				tStep=thetaStep[i]*Math.PI/180;				for(j=0;j<jLen[i];j++){					midsArray[i][j]=new Vector3D(rad*Math.sin(i*pStep)*Math.sin(j*tStep),-rad*Math.cos(i*pStep),-rad*Math.sin(i*pStep)*Math.cos(j*tStep));					holdersArray[i][j]=new Sprite();					holdersArray[i][j].name="pic"+String(i)+"_"+String(j);					holdersArray[i][j].addChild(thumbsArray[i][j]);					thumbsArray[i][j].x=-thumbWidth/2;					thumbsArray[i][j].y=-thumbHeight/2;					spSphere.addChild(holdersArray[i][j]);					holdersArray[i][j].x=midsArray[i][j].x;					holdersArray[i][j].y=midsArray[i][j].y;					holdersArray[i][j].z=midsArray[i][j].z;					holdersArray[i][j].rotationX=phiTilt[i];					holdersArray[i][j].rotationY=-j*thetaStep[i];				}			}			zSortPics();			}				/*		'zSortPics' depth-sorts all thumbnails corresponding to each view of		the sphere. It sorts thumbnails by removing them (or more precisely		their holders, holdersArray[i][j], as children of spSphere and then reassigning		them based on the z-coordinates of their midpoints.		*/				public function zSortPics():void {			var distArray:Array=[];							var dist:Number;			var i:int;			var j:int;			var k:int;			var curMatrix:Matrix3D;			var curMid:Vector3D;			curMatrix=spSphere.transform.matrix3D.clone();							while(spSphere.numChildren>0){				spSphere.removeChildAt(0);			}							for(i=0;i<7;i++){					for(j=0;j<jLen[i];j++){						curMid=curMatrix.deltaTransformVector(midsArray[i][j]);						dist=curMid.z;						distArray.push([dist,i,j]);					}			}							distArray.sort(byDist);			  			for(k=0;k<distArray.length;k++){				  spSphere.addChild(holdersArray[distArray[k][1]][distArray[k][2]]);				  holdersArray[distArray[k][1]][distArray[k][2]].alpha=Math.max(k/(distArray.length-1),0.5);			}		}				private function byDist(v:Array,w:Array):Number {			 if (v[0]>w[0]){				return -1;			  } 			  else if (v[0]<w[0]){				return 1;			  } 			  else {				return 0;			  }		}				/*		The function that rotates the sphere in response to the user moving the mouse.		Note we are setting the z coordinate to 0 before rotation. Otherwise,		the non-zero translation coefficients produce undesirable effects.		Note also that we do not use this function in 'autoRotate'. That is because		when the sphere auto-rotates we want it to revolve about is pole-to-pole		axis. That means prepending rather than appending rotation.		See the function 'autoRotate' above.		*/		public function rotateSphere(rotx:Number,roty:Number,rotz:Number):void {			  spSphere.z=0;			  spSphere.transform.matrix3D.appendRotation(rotx,Vector3D.X_AXIS);			  spSphere.transform.matrix3D.appendRotation(roty,Vector3D.Y_AXIS);			  spSphere.transform.matrix3D.appendRotation(rotz,Vector3D.Z_AXIS);			  spSphere.z=rad;			  zSortPics();		}	}	}