package BubMod.view {		import org.puremvc.as3.interfaces.*;    import org.puremvc.as3.patterns.mediator.Mediator;	import BubMod.model.*;	import flash.display.*;	import flash.events.*;	import BubMod.view.components.*;	import flash.geom.*;		public class EntityMediator extends Mediator implements IMediator     {				// Public Properties:		// Private Properties:			// Constants:		public static const NAME:String = "EntityMediator";		public static var count:int=0;		public var id:int;				private var rotateEntity:Boolean = false;		private var _tableShowing:Boolean = false;				// Constructor		public function EntityMediator( entity:EntityMC ) {        	super( NAME+String(count), entity);			//Set the id of the mediator equal to the count (this allows us to have a unique mediator for each entity)        	this.id=count;			//Set the entity id			entity.setEntityId(count);			//Increment the count so the next entity will also have a unique id			count++;						//Add some event listeners			entity.targetObject.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDownEvent);			entity.targetObject.addEventListener(MouseEvent.MOUSE_UP, onMouseUpEvent);			//removed for the moment			//entity.targetObject.addEventListener(MouseEvent.MOUSE_MOVE,sphereMove);			entity.targetObject.addEventListener(MouseEvent.MOUSE_OVER, onMouseOver);			entity.targetObject.addEventListener(MouseEvent.MOUSE_OUT, onMouseOut);			entity.targetObject.addEventListener(MouseEvent.CLICK, showTable);						// Retrieve reference to frequently consulted Proxies			entityDataProxy = facade.retrieveProxy( EntityDataProxy.NAME ) as EntityDataProxy;		}				//////////////////////////////////////////////////////////////////////        //        // showTable        //        //////////////////////////////////////////////////////////////////////		//Function which shows and hides the 2D representation of the bubble        private function showTable(event:MouseEvent):void         {			//If the table is currently showing than we want to remove it			if (_tableShowing)			{				sendNotification(ApplicationFacade.REMOVE_TABLE, entity.expandedTable);			}			//Otherwise we want to add it			else			{				//Create a new table				var entityName:String = entity.getName();				entity.expandedTable = new Table(entityName);				var attributesList:Array = entity.getAttributes();								//Add each of the entities attributes to the entity table				if (attributesList != null && attributesList.length > 0)				{					for (var i:int = 0; i< attributesList.length; i++)					{						entity.expandedTable.addAttribute(attributesList[i].getAttributeName());					}				}				//Tell the stage to add the table to the stage				sendNotification(ApplicationFacade.ADD_TABLE, entity);			}						_tableShowing = !_tableShowing;		}		//////////////////////////////////////////////////////////////////////        //        // onMouseDownEvent        //        //////////////////////////////////////////////////////////////////////		//Function used to rotate an individual bubble        private function onMouseDownEvent(event:MouseEvent):void         {			entity.targetObject.prevX=entity.targetObject.mouseX;			entity.targetObject.prevY=entity.targetObject.mouseY;			rotateEntity = true;        }				//////////////////////////////////////////////////////////////////////        //        // onMouseUpEvent        //        //////////////////////////////////////////////////////////////////////        private function onMouseUpEvent(event:MouseEvent):void         {			rotateEntity = false;        }				//////////////////////////////////////////////////////////////////////        //        // onMouseOver        //        //////////////////////////////////////////////////////////////////////		//If the user scrolls over the entity then we want to show the relationships        private function onMouseOver(event:MouseEvent):void         {			sendNotification(ApplicationFacade.BUILD_RELATIONSHIPS, entity);        }				//////////////////////////////////////////////////////////////////////        //        // onMouseOut        //        //////////////////////////////////////////////////////////////////////		//If the user scrolls off the entity then we want to remove the relationships        private function onMouseOut(event:MouseEvent):void         {			sendNotification(ApplicationFacade.REMOVE_RELATIONSHIPS, entity);        }				// Return list of Nofitication names that Mediator is interested in		override public function listNotificationInterests():Array {		    			return  [			        ApplicationFacade.RENDER,					ApplicationFacade.UPDATE			        ];		}				override public function handleNotification(note:INotification):void		{			//Check that the notification is for this entity			if ( int( note.getType() ) != this.id) return // not directed to this entity			switch( note.getName() )			{				  case ApplicationFacade.RENDER:				  	//if (!rotateEntity)					//{						var camera:EntityCamera = note.getBody() as EntityCamera;						render(camera);						sendNotification(ApplicationFacade.SORT_DEPTHS, entity);					//}					break;				case ApplicationFacade.UPDATE:					//if (!rotateEntity)					//{						entity.spaceObject.update();					//}					break;			}		}				private function get entity():EntityMC		{			return viewComponent as EntityMC;		}			private var entityDataProxy:EntityDataProxy;		private var schemaDataProxy:SchemaDataProxy;				//Function to render the entity as it is updated		private function render(camera:EntityCamera):void{			// position			var x:Number = entity.spaceObject.x - camera.x;			var y:Number = entity.spaceObject.y - camera.y;			var z:Number = entity.spaceObject.z - camera.z;						//y axis rotation			var radians:Number = camera.ty*(Math.PI/180);			var xTemp:Number = Math.sin(radians)*z + Math.cos(radians)*x;			var zTemp:Number = Math.cos(radians)*z - Math.sin(radians)*x;			x = xTemp;			z = zTemp;			//x axis rotation			radians = camera.tx*(Math.PI/180);			var yTemp:Number = Math.cos(radians)*y - Math.sin(radians)*z;			zTemp = Math.sin(radians)*y + Math.cos(radians)*z;			y = yTemp;			z = zTemp;						//z axis rotation			radians = camera.tz*(Math.PI/180);			xTemp = Math.cos(radians)*x + Math.sin(radians)*y;			yTemp = Math.sin(radians)*x - Math.cos(radians)*y;			x = xTemp;			y = yTemp;						// rotations			var tx:Number = SpaceObject.convertAngleTo360(camera.tx - entity.spaceObject.tx + 270);			var ty:Number = SpaceObject.convertAngleTo360(camera.ty - entity.spaceObject.ty + 270);			var tz:Number = SpaceObject.convertAngleTo360(camera.tz - entity.spaceObject.tz + 270);			// scale factor			var scale:Number = camera.fl/(camera.fl+z);						// create new spaceObject for update			var updateObject:SpaceObject = new SpaceObject(x,y,z,tx,ty,tz);			updateTargetObject(updateObject,scale);			if (entity.expandedTable != null)				updateExpandedTable(scale);		}		private function updateTargetObject(spaceObject:SpaceObject,scale:Number):void{			// position			entity.targetObject.x = scale * spaceObject.x;			entity.objectName.x = (entity.targetObject.x - entity.targetObject.width/2);			entity.targetObject.y = scale * spaceObject.y;			entity.objectName.y = entity.targetObject.y - entity.targetObject.width;						// scale			if(scale>1){				entity.targetObject.scaleX = entity.objectName.scaleX = 0;				entity.targetObject.scaleY = entity.objectName.scaleY = 0;				entity.targetObject.scaleZ = entity.objectName.scaleZ = 0;			}else{				entity.targetObject.scaleX = entity.objectName.scaleX = scale;				entity.targetObject.scaleY = entity.objectName.scaleY = scale;				entity.targetObject.scaleZ = entity.objectName.scaleZ = scale;			}									// visibility			entity.targetObject.visible = entity.objectName.visible = (spaceObject.z >= 0);						// depth			//**Zsorter should take care of the depth sorting**			entity.targetObject.z = entity.objectName.z = scale * spaceObject.z;		}				//Updates the 2D tables position so it moves with the entity		private function updateExpandedTable(scale:Number):void {			entity.expandedTable.x = entity.targetObject.x;			entity.expandedTable.y = entity.targetObject.y;			entity.expandedTable.z = entity.targetObject.z;						// scale			if(scale>1){				entity.expandedTable.scaleX = 0;				entity.expandedTable.scaleY = 0;				entity.expandedTable.scaleZ = 0;			}else{				entity.expandedTable.scaleX  = scale;				entity.expandedTable.scaleY = scale;				entity.expandedTable.scaleZ = scale;			}						entity.expandedTable.visible = (entity.targetObject.z >= 0);		}				//Function which rotates the individual sphere		private function sphereMove(e:MouseEvent):void {			if (rotateEntity)			{				//Get the spheres previous x and y positions		        var locX:Number=entity.targetObject.prevX;				var locY:Number=entity.targetObject.prevY;						//set the spheres previous position equal to the mouses position				entity.targetObject.prevX=entity.targetObject.mouseX;				entity.targetObject.prevY=entity.targetObject.mouseY;								//Call the rotate sphere function to rotate the sphere				entity.targetObject.rotateSphere(entity.targetObject.prevY-locY,-(entity.targetObject.prevX-locX),0);								//e.updateAfterEvent();			}		}	}}